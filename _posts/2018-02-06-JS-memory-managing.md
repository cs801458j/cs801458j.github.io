# 자바스크립트 메모리 관리

- 본 글은 MDN의 자바스크립트 메모리 관리 라는 글을 보고 오랜만에 JS관련 좋은 글을 보게되어 작성하게 되었습니다.
- 원글 링크는 [MDN JS 메모리 관리](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management) 입니다.


## 자바스크립트에서는 메모리 관리를 할 수 있는걸까?

- 자바스크립트를 어느 정도 사용했다고 생각했지만, 정말 우물 안 개구리라는 사실을 최근에 react를 하면서 실감하고 있습니다.
- ES5, ES6도 제대로 사용하지 못하면서 정말 야매로 자바스크립트를 사용해왔다는 사실은 자괴감만 느끼게 해줬습니다.
- 물론 js에서 메모리 관리를 할 수 있을 것이라는 생각도 해본적이 없습니다. 그렇게 엄청난 메모리가 누수되는(...) 쓰레기 코드를 양산하며 자바스크립트를 사용해왔습니다.
- C와 같은 경우는 malloc(), free()를 사용해서 메모리를 할당하고, 해제할 수 있는데 과연 자바스크립트는 어떻게 메모리 관리를 해주는 것일까요?

## 메모리 생존주기

- 놀랍게도 자바스크립트도 메모리 생존 주기가 있었습니다(...).

1. 필요할 때 할당.
2. 사용. (읽기, 쓰기)
3. 필요 없어지면 해제.

- 음? 필요 없어지면 해제한다는 부분이 가장 이해되지 않지만, 설명을 참고하면 명시적으로 free 해주지 않는다는 뜻이랍니다.
- 조금 더 자세히 살펴봐야 할 필요가 있다고 생각이 됩니다.

## 자바스크립트에서 메모리 할당하기

### 값 초기화

- 자바스크립트에서는 프로그래머들이 메모리를 하나하나 할당하는 고생을 줄여주기 위해 **값을 선언할 때** 메모리를 할당합니다.

```
var _integer = 3; // 메모리 할당(정수)
var _string = "eunjeong" // 메모리 할당(문자열)

var person = {
  age: 1,
  address: null
};  // 객체와 그 객체에 포함된 값들을 담기 위한 메모리 할당

function sum(a, b){
  return a+b;
} //  함수를 위한 할당(함수 == 호출 가능한 object)

someElement.addEventListener('click', function(){
  someElement.style.color = 'green';
  }, false);  //  함수식 또한 객체를 담기 위한 메모리를 할당한다.
```
-----------------------------------

### 함수 호출을 통한 할당
------------------------------------------------------------
- 몇 가지 함수에서도 메모리 할당이 일어납니다.
~~~
var date = new Date(); // Date 개체를 위해 메모리 할당
var domElement = document.createElement('div'); //  DOM 엘리먼트를 위해 메모리를 할당
~~~

- 메소드 일부도 새로운 값이나 객체를 담기 위해 메모리 할당을 한다.

```
var _string = "hello";
var _string2 = _string.substr(0,3); //  js에서 문자열은 불변(immutable)하는 값이기 때문에 범위 (0,3)만 저장(메모리 새로 할당하지 않음)

var _array = ["hello", "world"];
var _array2 = ["goodbye", "world"];
var _array3 = _array.concat(_array2); //  새로운 배열 원소 개수 = 4

```

## 값 사용
------------------------------------------------
- 할당된 메모리를 읽고 쓰는 것을 의미합니다. 주로 변수나 오브젝트 속성값을 읽고 쓸 때 값 사용이 발생합니다.
- 함수를 호출할 때 인수를 넘기는 경우에도 발생합니다.

## 할당된 메모리가 더 이상 필요없을 때 해제하기
------------------------------------------------------------
- **할당된 메모리가 더 이상 필요없을 때** 를 알아내는 것이 힘들기 때문에 이 단계에서 문제가 많이 발생한다고 합니다.
- C같은 경우는 메모리가 필요없어지면 free()해주면 되지만, Java같은 고급 인터프리터들은 **가비지 콜렉터** 를 가지고 있기 때문에 스스로(?) 결정하여 메모리가 필요없어 지면 해제합니다.

## 가비지 컬렉션
-------------------------------------
- **필요 없는 메모리 찾기** 는 비결정적이기 때문에, 자바스크립트는 **더 이상 필요없는 몇몇 메모리** 를 찾습니다.

### 참조
--------------------------------------------
- 모든 자바스크립트 오브젝트는 prototype을 암시적으로 참조하고, 그 오브젝트의 속성을 명시적으로 참조합니다. (ex. A 메모리를 통해 B 메모리에 접근할 수 있다면, 'B는 A에 참조된다'라고 합니다.)

### Reference-counting(참조-세기) 가비지 컬렉션
------------------------------------------------------
- Reference-counting은 **어떤 다른 오브젝트도 참조하지 않는 오브젝트** 를 찾아 그 오브젝트에 대해 가비지 컬렉션을 수행하는 알고리즘이다.

```
var outerObject = {
  midObject:{
    innerObj:2
  }
};  //  오브젝트 2개 생성. 한 오브젝트는 다른 오브젝트의 속성으로 참조됨.
//  가비지 콜렉션이 수행될 메모리는 하나도 없는 상태.

var outerObjectM = outerObject2.midObject;  //  outerObject2는 참조 2개 가짐. outerObject2가 속성으로 참조, outerObjectM 변수 참조.

var outerObject2 = outerObject;   //  위의 오브젝트를 참조하는 변수
outerObject = 1; // outerObject2가 위의 오브젝트를 참조하는 유일한 변수가 됨.

outerObject2 = "hello"; //  outerObject 변수가 참조했던 오브젝트를 참조하는 오브젝트가 사라졌다.
// 하지만, 아직 outerObject의 midObject속성이 'outerObjectM' 변수에 의해 참조되서 아직 가비지 콜렉션 수행되지 않는다.

outerObjectM = null;  //  outerObject가 참조했던 오브젝트를 참조하는 다른 변수가 이제 모두 없어졌으므로 가비지 콜렉션 수행.
```

### 한계

- 두 오브젝트가 서로를 참조할 때, 두 오브젝트 모두 필요 없어져도 가비지 콜렉션을 수행할 수 없다.
- 이 때, 메모리 누수가 발생하게 된다.

### Mark-and-sweep(표시하고-쓸기) 알고리즘

- **닿을 수 없는 오브젝트** 에 대해 가비지 콜렉션을 수행하는 알고리즘입니다.
- roots(전역 변수들의 집합)라는 오브젝트들의 집합에서 가비지 콜렉터가 roots가 참조하지 않는(참조를 찾다가 참조가 없는.. 애들) 오브젝트들에 대해 가비지 콜렉션을 수행합니다.
- 순환 참조 문제가 해결되게 된다!
- 한계는 오브젝트들이 명시적으로 닿을 수 없어져야 한다는 것인데, 사람들이 별 관심이 없다는.. 것이다.

### 결론

- 뭔가 결말이 허무한 느낌이 들지만, 메모리 누수가 발생하지 않는 좋은 코드를 잘 만들어야겠다는 생각이 듭니다.
